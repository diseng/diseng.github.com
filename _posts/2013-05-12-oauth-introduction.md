---
layout: post
title : OAuth2.0简介
category : translate
tags : [translate]
---
{% include JB/setup %}

## 1. 简介

在传统的客户端-服务器的身份验证模型中，客户端向服务器提供用户的凭据(如用户名,密码等),请求访问服务器的受限资源（受保护的资源）。为了提供第三方应用程序访问受限资源，用户需要将他的凭证共享给第三方。这就会产生一些问题和限制:

    1)第三方应用程序会请求存储用户的凭证以供未来使用,比如明文存储了用户的密码
    2)服务器需要支持密码认证，即使存在密码固有的安全薄弱环节
    3)用户没有能力去限制第三方应用程序访问受限资源的时间或者受限资源的范围
    4)用户一旦修改了凭证,则所有第三方应用程序保存的凭证都会失效,而如果要撤销某个应用的授权,则必须修改此应用的凭证
    5)对任何第三方应用程序的妥协,将会导致用户对其密码和受限资源的妥协

OAuth通过引入授权层,分离出不同的角色,解决了这些问题.在OAuth协议中,客户端访问服务器资源受用户控制,由资源服务器负责处理,并且使用与用户不同的访问凭证.

为了代替使用用户凭证访问受限资源,客户端需要获得一个访问令牌(access token)——一个标识了特定范围,生命周期和其他访问属性的字符串.访问令牌是在用户授权下,由授权服务器发放给第三方客户端的.客户端使用访问令牌就可以访问用户的受限资源了.

举个例子,用户可以授权一个提供打印服务的客户端访问其存储在图片服务器中的图片,而不用共享其在图片服务器中的账号和密码.用户只需授权一个图片服务器信赖的授权服务器来为客户端发放一个访问令牌.

### 1.1 角色

OAuth定义了4个角色:

资源拥有者

    可以授权访问受限资源的实体.当资源拥有者是一个人,通常被称为终端用户

资源服务器

    资源服务器存储着受限资源,通过使用访问令牌可以接受和回应受限资源的请求操作

客户端

    使用资源拥有者的授权,代替资源拥有者请求受限资源的应用程序.术语"客户端"并不表明任何特别的实现细节(如,应用程序是否在服务器,桌面或者其他设备上执行)

授权服务器

    授权服务器会在成功验证资源拥有者并且获得授权后,为客户端发放访问令牌.

授权服务器和资源服务器的交互作用不在本规范的说明范围内.授权服务器和资源服务器可以是同一台服务器,也可以是不同的服务器.一台授权服务器也可以为多台资源服务器提供服务.

### 1.2 协议流程

     +--------+                               +---------------+
     |        |--(A)- Authorization Request ->|   Resource    |
     |        |                               |     Owner     |
     |        |<-(B)-- Authorization Grant ---|               |
     |        |                               +---------------+
     |        |
     |        |                               +---------------+
     |        |--(C)-- Authorization Grant -->| Authorization |
     | Client |                               |     Server    |
     |        |<-(D)----- Access Token -------|               |
     |        |                               +---------------+
     |        |
     |        |                               +---------------+
     |        |--(E)----- Access Token ------>|    Resource   |
     |        |                               |     Server    |
     |        |<-(F)--- Protected Resource ---|               |
     +--------+                               +---------------+

                     Figure 1: Abstract Protocol Flow


图1是OAuth2.0协议的抽象流程图,描述了4个角色的交互作用,包括以下几步:

(A)

    客户端向资源拥有者请求授权.授权请求可以直接发向资源拥有者(如图),或者更好的方式是通过授权服务器作为一个中介间接发向资源拥有者.

(B)

    客户端接收授权许可.授权许可代表了资源拥有者的授权,通常使用本规范定义的4种许可类型来表示,也可以使用扩展的许可类型.许可类型由客户端请求授权的方法和授权服务器支持的类型共同决定.

(C)

    客户端通过提供授权许可,请求授权服务器发放访问令牌.

(D)

    授权服务器认证客户端并验证授权许可,如果验证通过,则向客户端发放一个访问令牌.

(E)

    客户端通过提供访问令牌,请求资源服务器上的受限资源.

(F)

    资源服务器验证访问令牌,如果验证通过,则对请求提供服务.

### 1.3 授权许可

授权许可是一个代表资源拥有者授权的证书(访问其受限资源),客户端通过它可以获得访问令牌.本规范定义了4中许可类型——授权码,隐含许可,资源拥有者口令凭证和客户端凭证,以及用于定义其他类型的扩展机制。

**1.3.1 授权码**

授权码是通过使用授权服务器作为客户端和资源拥有者之间的中介而获得的授权许可.与直接向资源拥有者请求授权不同的是,客户端会向资源拥有者指示一个授权服务器,由授权服务器指示资源拥有者返回给客户端授权码.

在授权服务器指示资源拥有者返回给客户端授权码之前,授权服务器会认证资源拥有者并取得授权.由于资源拥有者只与授权服务器进行身份验证，从而永远不会与客户端共享资源拥有者的凭据。

授权码提供了一些重要的安全益处,如认证客户端的能力,直接将访问令牌传输给客户端而不用经过资源拥有者的用户代理,避免潜在的暴露给其他人,包括资源拥有者.

**1.3.2 隐含许可**

隐含许可是一种简单的授权码流程,是为客户端在浏览器中使用脚本语言(如JavaScript)获得授权许可而优化的.在隐含许可流程中,客户端并不先获得授权码,而是直接获得访问令牌.其许可类型是隐式的,因为没有中间证书(如授权码)被发放.

在隐含许可流程中发放一个访问令牌,授权服务器不需要认证客户端.在一些情况下,客户端身份可以通过分发给客户端访问令牌的重定向URI来验证.通过访问资源拥有者的用户代理,访问令牌可能会暴露给资源拥有者或者其他应用程序.

隐含许可使得一些客户端提高了响应速度和效率,因为它减少了获得访问令牌的轮回次数.然而,需要权衡考虑其带来的便利和安全问题,来决定是否使用.

**1.3.3 资源拥有者口令凭证**

资源拥有者口令凭证(如用户名和密码)能够直接用来作为授权许可获得访问令牌.此类凭证应该用在资源拥有者和客户端高度信赖的情况下(如客户端是设备操作系统的一部分或者是一个有高度特权的应用程序),并且其他授权许可类型不可得的情况下.

尽管这种许可类型需要客户端直接访问资源拥有者的凭证,但是只用来完成一次获得访问令牌的请求.通过更新或者更改为一个长期有效的访问令牌,这种许可类型可以消除客户端存储资源拥有者凭证以供未来使用的需求.

**1.3.4 客户端凭证**

当授权范围限制于客户端控制下的受限资源或者先前由授权服务器安排的受限资源时,客户端凭证(或者其他形式的客户端身份验证)就能被作为授权许可使用.客户端凭证通常在客户端（客户端也是资源拥有者）以自己的名义行事或者请求访问先前由授权服务器安排的受限资源时作为授权许可.

### 1.4 访问令牌

访问令牌是用来访问受限资源的凭证.访问令牌是一个字符串，代表颁发给客户端的授权.这个字符串对客户端通常是不透明的.令牌代表了特定的范围和访问时间,由资源拥有者授权,资源服务器和授权服务器执行.

令牌可以表示一个标识符，用于检索授权信息，也可能自包含可验证方式（比如,一个令牌字符串包含了一些数据和签名的）的授权信息。为了让客户端使用令牌,一些超出本规范范围的额外授权凭证也有可能被用到.

访问令牌提供了一个抽象层,使用一个资源服务器能够理解的令牌代替了不同的授权结构(如用户名和密码).这种抽象使得发放访问令牌比授权许可获得访问令牌更严格,也处移了资源服务器需要理解不同授权方法的必要.

根据资源服务器安全需求,访问令牌可以有不同的格式,结构和利用方法(比如,加密属性).访问令牌的属性和访问受限资源的方法不在本规范范围内.



翻译了一下午才翻译了这么点,更多的请看[这里吧](http://tools.ietf.org/html/rfc6749)

[这里](http://blog.csdn.net/seccloud/article/details/8192707)也有一篇文章,讲到了OAuth的Web安全